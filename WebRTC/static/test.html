<!DOCTYPE html>
<html lang="ko">
<head>
    <title>Video Provider</title>
    <script src="https://cdn.jsdelivr.net/npm/sockjs-client@1/dist/sockjs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@stomp/stompjs@7.0.0/bundles/stomp.umd.min.js"></script>
</head>
<body>
<video id="localVideo" autoplay playsinline></video>
<video id="remoteVideo" autoplay playsinline></video>
<button id="startButton">Start WebRTC</button>

<script>
    const localVideo = document.getElementById('localVideo');
    const remoteVideo = document.getElementById('remoteVideo');
    const startButton = document.getElementById('startButton');
    
    let localStream;
    let peerConnection;
    let stompClient;
    let socket;

    // 로컬 비디오 스트림 설정
    async function setupLocalStream() {
        localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
        localVideo.srcObject = localStream;
    }

    // WebSocket 및 STOMP 연결 설정
    function setupWebSocket() {
        // socket = new SockJS('/ws/ai/testkey');  // key는 필요에 맞게 변경
        socket = new SockJS('http://localhost:8080/ws/ai/testkey');
        // WebSocket으로 변경
        // const socket = new WebSocket('ws://localhost:8000/ws/ai/testkey');
        stompClient = new StompJs.Client({
            webSocketFactory: () => socket,
            reconnectDelay: 5000,
            debug: (str) => {
                console.log(`STOMP 디버그 로그: ${str}`);  // STOMP 디버그 로그 출력
            }
        });

        stompClient.onConnect = (frame) => {
            console.log('STOMP 연결 성공', frame);
            
            // 구독 설정
            stompClient.subscribe('/sub/cam/123', (message) => {
                console.log("메시지 수신: ", message.body);  // 로그 추가
                const signal = JSON.parse(message.body);
                console.log("handleSignal 호출 전: ", signal);  // handleSignal 호출 전 로그
                try {
                    const signal = JSON.parse(message.body);
                    handleSignal(signal);
                } catch (e) {
                    console.error("메시지 파싱 오류: ", e);
                }
            });

            // WebRTC Offer 생성 및 전송
            createOffer();
        };

        stompClient.onStompError = (frame) => {
            console.error('STOMP 오류 발생: ', frame);
        };

        stompClient.onWebSocketError = (error) => {
            console.error('WebSocket 오류 발생: ', error);
        };
        // 연결이 제대로 안 될 경우를 대비해 추가적인 로그
        stompClient.onWebSocketClose = (event) => {
            console.error('WebSocket 연결이 닫혔습니다: ', event);
        };

        stompClient.activate();
    }

    // STOMP 연결 상태를 확인한 후에만 publish 호출
    function sendMessage(destination, body) {
        if (stompClient.connected) {
            console.log(`메시지 전송: ${body}`);  // 메시지 전송 로그 추가
            stompClient.publish({
                destination: destination,
                body: body
            });
        } else {
            console.error('STOMP 연결이 아직 완료되지 않았습니다.');
        }
    }

    // WebRTC Offer 생성
    function createOffer() {
        console.log("WebRTC Offer 생성 중...");  // 디버그 로그 추가
        peerConnection = new RTCPeerConnection();
        // const peerConnection = new RTCPeerConnection({
        //     iceServers: [
        //         { urls: "stun:stun.l.google.com:19302" }  // 공용 STUN 서버
        //     ]
        // });


        peerConnection.onicecandidate = event => {
            if (event.candidate) {
                console.log("ICE Candidate 생성: ", event.candidate);  // ICE Candidate 로그 추가
                // ICE 후보 정보를 전송할 때 foundation 포함
                const candidateData = {
                    type: 'candidate',
                    data: {
                        candidate: event.candidate.candidate,
                        sdpMid: event.candidate.sdpMid,
                        sdpMLineIndex: event.candidate.sdpMLineIndex,
                        foundation: event.candidate.foundation,  // foundation 필드 추가
                        component: event.candidate.component,
                        priority: event.candidate.priority,
                        protocol: event.candidate.protocol,
                        ip: event.candidate.address,
                        port: event.candidate.port,
                        type: event.candidate.type,
                        tcpType: event.candidate.tcpType
                    }
                };

                // 메시지를 서버로 전송
                sendMessage('/pub/cam/123', JSON.stringify(candidateData));
                // sendMessage('/pub/cam/123', JSON.stringify({
                //     type: 'candidate',
                //     data: event.candidate
                // }));
            }
        };

        peerConnection.ontrack = event => {
            console.log("트랙 수신: ", event.streams);  // 트랙 수신 로그 추가
            remoteVideo.srcObject = event.streams[0];
        };

        localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

        peerConnection.createOffer().then(offer => {
            console.log("WebRTC Offer 생성 완료: ", offer);  // Offer 생성 로그 추가
            peerConnection.setLocalDescription(offer);

            // STOMP를 통해 Offer 전송
            sendMessage('/pub/cam/123', JSON.stringify({
                type: 'offer',
                data: offer
            }));
            console.log("Offer 전송: ", offer);  // Offer 전송 로그
        });
    }

    // WebRTC Answer 생성
    function createAnswer(offer) {
        peerConnection = new RTCPeerConnection();

        peerConnection.onicecandidate = event => {
            if (event.candidate) {
                // sendMessage('/pub/cam/123', JSON.stringify({
                //     type: 'candidate',
                //     data: event.candidate
                // }));
                console.log("ICE 후보 데이터: ", event.candidate);  // ICE 후보 데이터 출력
                sendMessage('/pub/cam/123', JSON.stringify({
                    type: 'candidate',
                    data: {
                        candidate: event.candidate.candidate,  // 전체 candidate 문자열
                        sdpMid: event.candidate.sdpMid,        // 필요 시 추가
                        sdpMLineIndex: event.candidate.sdpMLineIndex
                    }
                }));
            }
        };

        peerConnection.ontrack = event => {
            remoteVideo.srcObject = event.streams[0];
        };

        peerConnection.setRemoteDescription(new RTCSessionDescription(offer));

        peerConnection.createAnswer().then(answer => {
            peerConnection.setLocalDescription(answer);

            sendMessage('/pub/cam/123', JSON.stringify({
                type: 'answer',
                data: answer
            }));
        });
    }

    function handleSignal(signal) {
        console.log("handleSignal 호출됨: ", signal);  // 로그 추가
        const signalData = signal.data;

        switch (signal.type) {
            case 'offer':
                createAnswer(signalData);
                break;
            case 'answer':
                console.log("Answer 수신: ", signalData);  // Answer 수신 로그
                peerConnection.setRemoteDescription(new RTCSessionDescription(signalData));
                break;
            case 'candidate':
                peerConnection.addIceCandidate(new RTCIceCandidate(signalData));
                break;
        }
    }

    // Start 버튼 클릭 시 WebRTC 연결 시작
    startButton.addEventListener('click', () => {
        setupLocalStream().then(() => {
            setupWebSocket();
        });
    });

</script>
</body>
</html>
